# 시간복잡도 이야기  
> 강정훈

#### 시간복잡도 개념은 "우리가 작성한 코드가 사용하고 있는 컴퓨터에서는 얼마나 잘돌아갈까?" 라는 질문에서 시작되었습니다.

#### 같은 결과값이 나오는 프로그램이라 하더라도 복잡하게 구현된 코드도 있지만 아주 간단하게 구현된 코드가 있습니다.
우리는 보통 아주 간단하게 구현된 코드를 선호합니다. 그 이유는 컴퓨터의 성능은 무한대가 아니기 때문이죠.

기업은 간단하고 효율적으로 코드를 짜는 사람을 뽑고 싶기 때문에 기업 코테시험에는 주어진 시간복잡도내에 문제를 풀 수 있도록 설계가 되어 있습니다.


### 백준 사이트 문제를 보면

![image](https://user-images.githubusercontent.com/80855939/210045545-bf809018-7020-4804-999e-c058af1da10d.png)

보통 "시간제한 1초" 라고 표시되어있습니다.

컴퓨터는 보통 1초에 10^8 즉 1억번 연산한다고 생각하시면 되는데요. 나의 풀이가 1억번 연산안에 끝나야 통과라고 이해하시면 될꺼같습니다.


### 그럼 1억번 연산을 어떻게 계산하느냐? 우리는 빅오 표기법을 사용합니다


빅오표기법의 상대적인 성능을 비교하는 표기법이며 쉽게 표를 통해 설명드리면 

빅오에 쓰인 n이 전부 같은 값이라 가정할 때 O(1)이 가장 빠르고 다음으로 O(log n), O(n), O(n log n), O(n^2), O(2^n), O(n!) 순으로 점점 느리다고 보시면 됩니다.

![image](https://user-images.githubusercontent.com/80855939/210039879-273bb1e7-db1a-491b-b005-1b1327470a77.png)


### 한 예시를 들어 보면

만약 저의 코드에 이중 for 문이 들어갔으면 O(n^2) 되겠으며, 만약 주어진 문제 n이 10^5 이게 되면 저의 코드는 시간 초과가 날것입니다.   
그렇기 때문에 대안으로 O(n^2)보다 낮은 O(log n), O(n), O(n log n) 고려하여 접근하게 될것입니다.

> 평소 문제 풀면서 시간복잡도를 계산하면서 푸는 습관은 좋은습관이 될꺼같습니다.(물론 저는 못하고 있습니다...)
> 감사합니다


